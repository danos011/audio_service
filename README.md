# Audio Service

WebSocket-сервис для обработки аудио-потоков с использованием межпроцессного взаимодействия (IPC) для масштабируемой обработки данных.

## Описание

Сервис принимает бинарные аудио-чанки от клиентов через WebSocket, передает их в отдельный процесс-обработчик через очередь, получает mock-транскрипции и отправляет результаты обратно клиентам в формате JSON.

### Основные возможности

- ✅ Прием бинарных аудио-данных от нескольких клиентов параллельно
- ✅ Асинхронная обработка через отдельный worker-процесс
- ✅ Межпроцессное взаимодействие через `multiprocessing.Queue`
- ✅ Поддержка множественных одновременных подключений
- ✅ Graceful shutdown с корректным завершением всех процессов
- ✅ Docker-контейнеризация для production

## Архитектура

```
┌─────────────┐
│   Client 1  │
│   Client 2  │──┐
│   Client N  │  │
└─────────────┘  │
                 │  WebSocket
                 ▼
         ┌───────────────┐
         │  FastAPI App  │
         │  (Main Process)│
         └───────────────┘
                 │
         ┌───────┴───────┐
         │               │
         ▼               ▼
    ┌─────────┐    ┌─────────┐
    │ Input Q │    │Output Q │
    └─────────┘    └─────────┘
         │               ▲
         │               │
         ▼               │
    ┌───────────────┐    │
    │ Worker Process│────┘
    │ (audio_handler)│
    └───────────────┘
```

### Компоненты

- **WebSocket сервер** (FastAPI) — принимает подключения, управляет клиентами, маршрутизирует сообщения
- **Input Queue** — очередь для передачи аудио-чанков от сервера к worker'у
- **Output Queue** — очередь для возврата транскрипций от worker'а к серверу
- **Worker Process** — отдельный процесс, обрабатывающий аудио и генерирующий mock-транскрипции
- **Sender Task** — асинхронная задача, которая отправляет результаты клиентам

## Технологический стек

- **Python 3.10+**
- **FastAPI** — веб-фреймворк и WebSocket-сервер
- **Uvicorn** — ASGI-сервер
- **multiprocessing** — межпроцессное взаимодействие через Queue
- **websockets** — клиентская библиотека
- **Docker & Docker Compose** — контейнеризация

## Структура проекта

```
audio_service/
├── server/                 # Серверная часть
│   ├── api/
│   │   ├── audio/
│   │   │   ├── handler.py  # WebSocket endpoint и обработка клиентов
│   │   │   └── worker.py   # Worker-процесс для обработки аудио
│   │   └── __init__.py     # Роутинг API
│   ├── main.py             # Точка входа, настройка FastAPI и lifecycle
│   ├── requirements.txt    # Зависимости сервера
│   ├── Dockerfile
│   └── entrypoint.sh
├── client/                 # Пример клиента
│   ├── client.py           # Тестовый WebSocket-клиент
│   ├── requirements.txt    # Зависимости клиента
│   ├── Dockerfile
│   └── entrypoint.sh
├── docker-compose.yml      # Конфигурация Docker Compose
├── entrypoint_compose.sh   # Скрипт управления Docker-стеком
└── README.md
```

## Установка и запуск

### Требования

- Python 3.10 или выше
- pip
- Docker и Docker Compose (для production)

### Локальная разработка

#### 1. Создание виртуального окружения

```bash
# В корне проекта
python -m venv venv

# Активация (Linux/macOS)
source venv/bin/activate

# Активация (Windows PowerShell)
# venv\Scripts\Activate.ps1
```

#### 2. Установка зависимостей

```bash
# Зависимости сервера
pip install -r server/requirements.txt

# Зависимости клиента (опционально, для тестирования)
pip install -r client/requirements.txt
```

#### 3. Запуск сервера

```bash
# Предоставить права на выполнение (один раз)
chmod +x server/entrypoint.sh

# Запуск сервера
./server/entrypoint.sh
```

Сервер будет доступен по адресу: `http://localhost:8000`

#### 4. Запуск клиента

В отдельном терминале:

```bash
chmod +x client/entrypoint.sh
./client/entrypoint.sh
```

Можно запускать несколько клиентов параллельно в разных терминалах — сервер поддерживает множественные подключения.

## API Документация

### Эндпоинты

#### `GET /api/audio/health`

Проверка работоспособности сервера.

**Ответ:**
```json
{
  "status": "ok"
}
```

#### `WebSocket /api/audio/ws`

WebSocket-эндпоинт для передачи аудио-данных.

**Подключение:**
```
ws://localhost:8000/api/audio/ws
```

**Формат сообщений:**

**От клиента к серверу:**
- Бинарные данные (bytes) — аудио-чанки
- Текстовые данные (string) — управляющие сообщения

**От сервера к клиенту (JSON):**

При отправке бинарного чанка:
```json
{
  "client_id": 123456789,
  "seq": 1,
  "chunk_size": 4096
}
```

При получении транскрипции:
```json
{
  "seq": 1,
  "transcription": "mock transcription for client 123456789 msg#1 (binary 4096 bytes)"
}
```

**Пример обработки ошибок:**
```json
{
  "error": "Expected binary audio chunk or text"
}
```

## Production (Docker)

Для развертывания в production используется Docker Compose. Управление стеком осуществляется через скрипт `entrypoint_compose.sh`.

### Подготовка

```bash
chmod +x entrypoint_compose.sh
```

### Команды

#### Запуск сервера и клиента(ов)

**Сборка образов и запуск с 1 клиентом (по умолчанию):**
```bash
./entrypoint_compose.sh --build --up
```

**Запуск с N клиентами:**
```bash
./entrypoint_compose.sh --build --up --client 5
```

**Только пересборка образов:**
```bash
./entrypoint_compose.sh --build
```

**Просмотр логов всех сервисов:**
```bash
./entrypoint_compose.sh --logs
```

**Остановка и удаление контейнеров:**
```bash
./entrypoint_compose.sh --down
```

**Изменение количества клиентов на лету:**
```bash
./entrypoint_compose.sh --up --client 3
```

### Переменные окружения

#### Сервер
- Порт по умолчанию: `8000`

#### Клиент
- `WS_URL` — URL WebSocket-сервера (по умолчанию: `ws://server:8000/api/audio/ws`)
- `MSGS` — количество сообщений для отправки (по умолчанию: `1000`)
- `RATE_MS` — интервал между сообщениями в миллисекундах (по умолчанию: `10`)

## Особенности реализации

### Обработка клиентов

- Каждому клиенту присваивается уникальный `client_id` на основе `id(websocket)`
- Поддержка последовательной нумерации сообщений (`seq`) для каждого клиента
- Автоматическая очистка при отключении клиента

### Worker Process

- Запускается как отдельный процесс при старте приложения
- Использует блокирующие операции для чтения из очереди
- Генерирует mock-транскрипции на основе полученных данных
- Корректно завершается по сигналу `(None, None, None)`

### Graceful Shutdown

При остановке сервера выполняются следующие действия:
1. Сигнализация sender-таске о завершении
2. Отправка сигнала завершения в worker-процесс
3. Ожидание завершения worker-процесса (с таймаутом)
4. Закрытие очередей (input_q, output_q)
5. Закрытие всех активных WebSocket-соединений

## Разработка

### Тестирование

Запустите сервер и подключите несколько клиентов для проверки параллельной обработки:

```bash
# Терминал 1: сервер
./server/entrypoint.sh

# Терминал 2: клиент 1
./client/entrypoint.sh

# Терминал 3: клиент 2
./client/entrypoint.sh
```

### Логирование

Сервер использует стандартное логирование Uvicorn. Для просмотра детальных логов:

```bash
# Локально
uvicorn main:app --host 0.0.0.0 --port 8000 --log-level debug

# Docker
./entrypoint_compose.sh --logs
```

## Лицензия

См. файл [LICENSE](LICENSE) для деталей.
